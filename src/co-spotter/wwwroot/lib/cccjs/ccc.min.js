var cccjs = function (a) { this.version = "0.0.2", this.versionName = "AngryWolf", a = a || {}, this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent), this.width = a.width || 900, this.height = a.height || 600, this.debugMod = a.debugMod, this.canvas = document.getElementById(a.canvas || "myCanvas"), this.ctx = this.canvas.getContext("2d"), this.progressBar = a.progressBar, this.allCanvasObjects = [], this.id = a.id || 1, this.sprite = "", this.inputHandler = new cccjs.inputHandler, this.selectedTool = "cursor-default", this.$http = a.$http, this.init() }; cccjs.prototype = { init: function () { var a, b = this; this.$http.get("/App/getPlan").then(function (b) { a = b.data, console.log(a) }, function (a) { return console.log("ERROR: PLAN INIT") }).then(function () { b.allCanvasObjects.push({}); var c = new Image; b.sprite = c, c.onload = function () { console.log("Sprite is loaded!") }, c.src = "./lib/cccjs/img/sprite.png"; for (var d = 0; d < a.markers.length; d++) { var e = a.markers[d], f = { id: e.id, sprite: c, type: "red", pos: { x: e.x, y: e.y } }; b.allCanvasObjects.push(new cccjs.Marker(f)) } }).then(function () { b.allCanvasObjects[0] = new cccjs.Plan({ src: a.planImg, width: a.planWidth, height: a.planHeight }) }).then(function () { b.isMobile ? b.addTouchListeners() : b.addMouseListeners(), b.run() }) }, update: function (a, b) { switch (this.allCanvasObjects[0].update("update", b), this.selectedTool) { case "cursor-default": for (var c = 0; c < this.allCanvasObjects.length; c++) { var d = this.allCanvasObjects[c]; d.update(a, b) } for (var e, c = 1; c < this.allCanvasObjects.length; c++) { var d = this.allCanvasObjects[c]; d.scale = .4, d.isMouseOver(b) && (e = d) } if (this.isMobile && b.isDragging) return; e && (e.scale = .55), "up" === a && this.inputHandler.clickedMarkers.length > 0 && (this.inputHandler.clickedMarkers[this.inputHandler.clickedMarkers.length - 1].click(), this.inputHandler.clickedMarkers = []); break; case "cursor-move": break; case "cursor-marker": if ("move" === a); else if ("down" === a) { var f = this.allCanvasObjects[0]; if (b.imagePos.x <= 0 || b.imagePos.x >= f.width || b.imagePos.y <= 0 || b.imagePos.y >= f.height) return; var g = { id: Math.random(100), sprite: this.sprite, type: "black", pos: { x: b.canvasPos.x, y: b.canvasPos.y } }, h = this; this.$http.post("/newmarker/" + h.id, { id: g.id, x: b.imagePos.x, y: b.imagePos.y }).then(function (a) { h.allCanvasObjects.push(new cccjs.Marker(g)) }, function (a) { console.log(a) }) } break; case "cursor-zoom-in": if ("down" === a && this.zoomEvent({ myDeltaY: -1 }), "zoom" === a) for (var c = 0; c < this.allCanvasObjects.length; c++) { var d = this.allCanvasObjects[c]; d.update(a, b) } break; case "cursor-zoom-out": if ("down" === a && this.zoomEvent({ myDeltaY: 1 }), "zoom" === a) for (var c = 0; c < this.allCanvasObjects.length; c++) { var d = this.allCanvasObjects[c]; d.update(a, b) } break; case "cursor-pin": break; case "cursor-photo": break; case "cursor-note": break; default: this.selectedTool = "cursor-default" } }, render: function () { this.width = this.canvas.width = this.canvas.parentElement.clientWidth, this.height = this.canvas.height = this.canvas.parentElement.clientHeight, console.log(this.width + " " + this.height), this.ctx.clearRect(0, 0, this.width, this.height); for (var a = 0; a < this.allCanvasObjects.length; a++) { var b = this.allCanvasObjects[a]; b.draw(this.ctx, this.width, this.height) } this.debugMod && this.log(this.inputHandler.canvasPos.x + " " + this.inputHandler.canvasPos.y + " " + this.inputHandler.imagePos.x + " " + this.inputHandler.imagePos.y + " " + this.inputHandler.isClicked + " " + this.inputHandler.isDragging + " " + this.inputHandler.dragVec.x + " " + this.inputHandler.dragVec.y + " " + this.inputHandler.zoomRatio + " " + this.selectedTool + " " + this.allCanvasObjects.length) }, run: function () { var a = this, b = function () { a.render(), window.requestAnimationFrame(b, a.canvas) }; window.requestAnimationFrame(b, a.canvas) }, setWidth: function (a) { }, setHeight: function (a) { }, addMouseListeners: function () { var a = this, b = this.inputHandler; this.canvas.addEventListener("mousemove", function (c) { var d = a.canvas.getBoundingClientRect(); if (b.canvasPos.x = Math.round(c.clientX - d.left), b.canvasPos.y = Math.round(c.clientY - d.top), b.isClicked && (b.isDragging = !0), b.isDragging) { var e = (b.canvasPos.x - b.lastPos.x) / b.zoomRatio, f = (b.canvasPos.y - b.lastPos.y) / b.zoomRatio; (Math.abs(e) > 7 || Math.abs(f) > 7) && (b.dragVec.x = -e, b.dragVec.y = -f) } a.update("move", b.getData()) }, !1), this.canvas.addEventListener("mousedown", function (c) { b.isClicked = !0, b.lastPos.x = b.canvasPos.x, b.lastPos.y = b.canvasPos.y, a.update("down", b.getData()) }, !1), this.canvas.addEventListener("mouseup", function () { b.isClicked = !1, a.update("up", b.getData()), b.isDragging && (b.dragVec.x = 0, b.dragVec.y = 0, b.isDragging = !1) }, !1), this.canvas.addEventListener("mouseout", function () { b.isClicked = !1, a.update("up", b.getData()), b.isDragging && (b.dragVec.x = 0, b.dragVec.y = 0, b.isDragging = !1) }, !1), this.canvas.addEventListener("mousewheel", function (b) { return "cursor-default" !== a.selectedTool && "cursor-zoom-in" !== a.selectedTool && "cursor-zoom-out" !== a.selectedTool ? void console.log("UH-UHH") : void a.zoomEvent(b) }, !1) }, addTouchListeners: function () { var a = this, b = this.inputHandler; this.canvas.addEventListener("touchstart", function (c) { var d = c.changedTouches; if (!(d.length > 1)) { var e = a.canvas.getBoundingClientRect(); b.canvasPos.x = Math.round(d[0].clientX - e.left), b.canvasPos.y = Math.round(d[0].clientY - e.top), b.isClicked = !0, b.lastPos.x = b.canvasPos.x, b.lastPos.y = b.canvasPos.y, a.update("down", b.getData()) } }, !1), this.canvas.addEventListener("touchmove", function (c) { var d = c.changedTouches; if (!(d.length > 1)) { var e = a.canvas.getBoundingClientRect(); if (1 == b.isClicked && (b.isDragging = !0), b.isDragging) { b.canvasPos.x = Math.round(d[0].clientX - e.left), b.canvasPos.y = Math.round(d[0].clientY - e.top); var f = (b.canvasPos.x - b.lastPos.x) / b.zoomRatio, g = (b.canvasPos.y - b.lastPos.y) / b.zoomRatio; (Math.abs(f) > 7 || Math.abs(g) > 7) && (b.dragVec.x = -f, b.dragVec.y = -g) } a.update("move", b.getData()) } }, !1), this.canvas.addEventListener("touchend", function (c) { b.isClicked = !1, a.update("up", b.getData()), b.isDragging && (b.dragVec.x = 0, b.dragVec.y = 0, b.isDragging = !1) }, !1), this.canvas.addEventListener("touchcancel", function (c) { b.isClicked = !1, a.update("up", b.getData()), b.isDragging && (b.dragVec.x = 0, b.dragVec.y = 0, b.isDragging = !1) }, !1) }, zoomEvent: function (a) { var b = this.inputHandler, c = a.myDeltaY || a.deltaY; a.deltaY && 1 == b.isClicked || (c < 0 ? (b.zoomRatio *= 1.08, b.zoomRatio > b.maxZoomRatio && (b.zoomRatio = b.maxZoomRatio)) : c > 0 && (b.zoomRatio /= 1.08, b.zoomRatio < b.minZoomRatio && (b.zoomRatio = b.minZoomRatio)), b.scale.x = this.width / b.zoomRatio, b.scale.y = this.height / b.zoomRatio, b.imgScale.x = this.width - b.scale.x, b.imgScale.y = this.height - b.scale.y, b.mouseScalePos.x = b.canvasPos.x / b.zoomRatio / b.scale.x * (b.imgScale.x - b.prevImgScale.x), b.mouseScalePos.y = b.canvasPos.y / b.zoomRatio / b.scale.y * (b.imgScale.y - b.prevImgScale.y), this.update("zoom", b.getData()), b.prevImgScale.x = b.imgScale.x, b.prevImgScale.y = b.imgScale.y) }, log: function (a) { this.ctx.font = "16pt Calibri", this.ctx.fillStyle = "black", this.ctx.fillText(a, 10, 25) }, setSelectedTool: function (a) { this.selectedTool = a }, setInitial: function () { } }, cccjs.inputHandler = function (a) { var a = a || {}; this.canvasPos = { x: 0, y: 0 }, this.imagePos = { x: 0, y: 0 }, this.lastPos = { x: 0, y: 0 }, this.dragVec = { x: 0, y: 0 }, this.scale = { x: 0, y: 0 }, this.imgScale = { x: 0, y: 0 }, this.prevImgScale = { x: 0, y: 0 }, this.mouseScalePos = { x: 0, y: 0 }, this.clickedMarkers = [], this.animQueue = [], this.isClicked = !1, this.isDragging = !1, this.isActive = !0, this.zoomRatio = 1, this.minZoomRatio = a.minZoomRatio || .6, this.maxZoomRatio = a.minZoomRatio || 1.6 }, cccjs.inputHandler.prototype = { getData: function () { return this }, setImagePos: function (a, b) { this.imagePos.x = a, this.imagePos.y = b }, setScale: function () { } }, cccjs.Plan = function (a) { var a = a || {}; this.img = new Image, this.src = a.src || "", this.isLoaded = !1, this.pos = { x: 0, y: 0 }, this.offset = { x: 0, y: 0 }, this.width = a.width, this.height = a.height, this.zoomRatio = 1, this.init() }, cccjs.Plan.prototype = { init: function () { this.img.load(this.src) }, update: function (a, b) { switch (a) { case "move": b.isDragging && (this.offset.x = b.dragVec.x, this.offset.y = b.dragVec.y); break; case "up": this.pos.x += this.offset.x, this.pos.y += this.offset.y, this.offset.x = 0, this.offset.y = 0; break; case "out": this.pos.x += this.offset.x, this.pos.y += this.offset.y, this.offset.x = 0, this.offset.y = 0; break; case "zoom": this.zoomRatio = b.zoomRatio, this.pos.x += b.mouseScalePos.x, this.pos.y += b.mouseScalePos.y; break; case "update": var c = Math.ceil(b.canvasPos.x / b.zoomRatio + (this.pos.x + this.offset.x)), d = Math.ceil(b.canvasPos.y / b.zoomRatio + (this.pos.y + this.offset.y)); b.setImagePos(c, d) } var c = Math.ceil(b.canvasPos.x / b.zoomRatio + (this.pos.x + this.offset.x)), d = Math.ceil(b.canvasPos.y / b.zoomRatio + (this.pos.y + this.offset.y)); b.setImagePos(c, d) }, draw: function (a, b, c) { a.drawImage(this.img, this.pos.x + this.offset.x, this.pos.y + this.offset.y, b / this.zoomRatio, c / this.zoomRatio, 0, 0, b, c) } }, cccjs.Marker = function (a) { this.id = a.id, this.width = null, this.height = null, this.pos = { x: a.pos.x, y: a.pos.y }, this.offset = { x: 0, y: 0 }, this.drag = { x: 0, y: 0 }, this.spriteCords = { redMarker: { x: 0, y: 0, w: 73, h: 102 }, blueMarker: { x: 74, y: 0, w: 73, h: 102 }, yellowMarker: { x: 148, y: 0, w: 73, h: 102 }, orangeMarker: { x: 222, y: 0, w: 73, h: 102 }, blackMarker: { x: 296, y: 0, w: 73, h: 102 } }, this.selectedMarker = null, this.scale = .4, this.type = a.type, this.isDragging = !1, this.isVisible = !0, this.sprite = a.sprite, this.init() }, cccjs.Marker.prototype = { init: function () { switch (this.type) { case "red": this.selectedMarker = this.spriteCords.redMarker, this.width = this.spriteCords.redMarker.w, this.height = this.spriteCords.redMarker.h; break; case "blue": this.selectedMarker = this.spriteCords.blueMarker, this.width = this.spriteCords.blueMarker.w, this.height = this.spriteCords.blueMarker.h; break; case "yellow": this.selectedMarker = this.spriteCords.yellowMarker, this.width = this.spriteCords.yellowMarker.w, this.height = this.spriteCords.yellowMarker.h; break; case "orange": this.selectedMarker = this.spriteCords.orangeMarker, this.width = this.spriteCords.orangeMarker.w, this.height = this.spriteCords.orangeMarker.h; break; case "black": this.selectedMarker = this.spriteCords.blackMarker, this.width = this.spriteCords.blackMarker.w, this.height = this.spriteCords.blackMarker.h; break; default: this.selectedMarker = this.spriteCords.redMarker, this.width = this.spriteCords.redMarker.w, this.height = this.spriteCords.redMarker.h } }, update: function (a, b) { switch (a) { case "move": b.isDragging && (this.drag.x = -(b.dragVec.x * b.zoomRatio), this.drag.y = -(b.dragVec.y * b.zoomRatio)); break; case "down": break; case "up": this.offset.x += this.drag.x, this.offset.y += this.drag.y, this.drag.x = this.drag.y = 0, !b.isDragging && this.isMouseOver(b) && b.clickedMarkers.push(this); break; case "out": this.offset.x += this.drag.x, this.offset.y += this.drag.y, this.drag.x = this.drag.y = 0; break; case "zoom": this.offset.x += (this.pos.x + this.offset.x) / b.scale.x * (b.imgScale.x - b.prevImgScale.x), this.offset.y += (this.pos.y + this.offset.y) / b.scale.y * (b.imgScale.y - b.prevImgScale.y), this.offset.x -= b.mouseScalePos.x * b.zoomRatio, this.offset.y -= b.mouseScalePos.y * b.zoomRatio } }, anim: function () { }, draw: function (a) { a.drawImage(this.sprite, this.selectedMarker.x, this.selectedMarker.y, this.selectedMarker.w, this.selectedMarker.h, this.pos.x + this.offset.x + this.drag.x - this.width / 2 * this.scale, this.pos.y + this.offset.y + this.drag.y - this.height * this.scale, this.width * this.scale, this.height * this.scale) }, getBoxModel: function () { return { x: this.pos.x + this.offset.x + this.drag.x - this.width / 2 * this.scale, y: this.pos.y + this.offset.y + this.drag.y - this.height * this.scale, w: this.width * this.scale, h: this.height * this.scale } }, isMouseOver: function (a) { var b = this.getBoxModel(); return a.canvasPos.x > b.x && a.canvasPos.x < b.x + b.w && a.canvasPos.y > b.y && a.canvasPos.y < b.y + b.h }, click: function () { console.log(this.id) } }, function () { Image.prototype.load = function (a, b) { var c = this, d = new XMLHttpRequest; c.completedPercentage = 0, d.open("GET", a, !0), d.responseType = "arraybuffer", d.onload = function (a) { var e = d.getAllResponseHeaders(), f = e.match(/^Content-Type\:\s*(.*?)$/im), g = f[1] || "image/png", h = new Blob([this.response], { type: g }); c.src = window.URL.createObjectURL(h), b && b(this) }, d.onprogress = function (a) { a.lengthComputable && (c.completedPercentage = parseInt(a.loaded / a.total * 100)), console.log("Loading " + c.completedPercentage) }, d.onloadstart = function () { console.log("Started Dowloading Image"), c.completedPercentage = 0 }, d.onloadend = function () { console.log("Completed"), c.completedPercentage = 100 }, d.send() }; var b = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent); b && window.addEventListener("load", function () { var a = !1, b = 0, c = function (c) { 1 == c.touches.length && (b = c.touches[0].clientY, a = 0 == window.pageYOffset) }, d = function (a) { var c = a.touches[0].clientY, d = c - b; return b = c, d > 0 ? void a.preventDefault() : void a.preventDefault() }; document.addEventListener("touchstart", c, !1), document.addEventListener("touchmove", d, !1) }) }();